// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v3.12.4
// source: controlplane/services.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { MessageResponse, StatusCode, statusCodeFromJSON, statusCodeToJSON } from "../common/common";
import { ValidationError } from "../common/validation";

export const protobufPackage = "controlplane";

export enum ServiceType {
  CLUSTER = 0,
  NODE = 1,
  UNRECOGNIZED = -1,
}

export function serviceTypeFromJSON(object: any): ServiceType {
  switch (object) {
    case 0:
    case "CLUSTER":
      return ServiceType.CLUSTER;
    case 1:
    case "NODE":
      return ServiceType.NODE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ServiceType.UNRECOGNIZED;
  }
}

export function serviceTypeToJSON(object: ServiceType): string {
  switch (object) {
    case ServiceType.CLUSTER:
      return "CLUSTER";
    case ServiceType.NODE:
      return "NODE";
    case ServiceType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ServiceStatus {
  OFFLINE = 0,
  PROVISIONING = 1,
  RUNNING = 2,
  DELETING = 3,
  ERROR = 4,
  UNRECOGNIZED = -1,
}

export function serviceStatusFromJSON(object: any): ServiceStatus {
  switch (object) {
    case 0:
    case "OFFLINE":
      return ServiceStatus.OFFLINE;
    case 1:
    case "PROVISIONING":
      return ServiceStatus.PROVISIONING;
    case 2:
    case "RUNNING":
      return ServiceStatus.RUNNING;
    case 3:
    case "DELETING":
      return ServiceStatus.DELETING;
    case 4:
    case "ERROR":
      return ServiceStatus.ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ServiceStatus.UNRECOGNIZED;
  }
}

export function serviceStatusToJSON(object: ServiceStatus): string {
  switch (object) {
    case ServiceStatus.OFFLINE:
      return "OFFLINE";
    case ServiceStatus.PROVISIONING:
      return "PROVISIONING";
    case ServiceStatus.RUNNING:
      return "RUNNING";
    case ServiceStatus.DELETING:
      return "DELETING";
    case ServiceStatus.ERROR:
      return "ERROR";
    case ServiceStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ServicePortType {
  IN = 0,
  OUT = 1,
  UNRECOGNIZED = -1,
}

export function servicePortTypeFromJSON(object: any): ServicePortType {
  switch (object) {
    case 0:
    case "IN":
      return ServicePortType.IN;
    case 1:
    case "OUT":
      return ServicePortType.OUT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ServicePortType.UNRECOGNIZED;
  }
}

export function servicePortTypeToJSON(object: ServicePortType): string {
  switch (object) {
    case ServicePortType.IN:
      return "IN";
    case ServicePortType.OUT:
      return "OUT";
    case ServicePortType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TakeAction {
  START = 0,
  STOP = 1,
  RESTART = 2,
  UNRECOGNIZED = -1,
}

export function takeActionFromJSON(object: any): TakeAction {
  switch (object) {
    case 0:
    case "START":
      return TakeAction.START;
    case 1:
    case "STOP":
      return TakeAction.STOP;
    case 2:
    case "RESTART":
      return TakeAction.RESTART;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TakeAction.UNRECOGNIZED;
  }
}

export function takeActionToJSON(object: TakeAction): string {
  switch (object) {
    case TakeAction.START:
      return "START";
    case TakeAction.STOP:
      return "STOP";
    case TakeAction.RESTART:
      return "RESTART";
    case TakeAction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Query */
export interface QueryId {
  serviceId: string;
}

export interface QueryServices {
  page: number;
  limit: number;
  search: string;
  sort: string;
  order: string;
}

export interface QueryTakeActions {
  action: TakeAction;
  serviceIds: string[];
}

export interface QueryLog {
  serviceId: string;
  /** default is 100 lines */
  limit: number;
  /** reversed page. if 1 this mean is the latest logs */
  page: number;
}

/** Utils */
export interface ServiceNodeField {
  key: string;
  value: string;
  /** text, number, boolean, options, etc */
  type: string;
}

export interface ServicePort {
  /** IN or OUT */
  type: ServicePortType;
  port: number;
  /** tcp, udp, etc */
  protocol: string;
  host: string;
  /** this mean, if true, expose to internet */
  enabledExpose: boolean;
}

export interface ServiceContainer {
  /** docker container id */
  id: string;
  name: string;
  /** image container used. */
  image: string;
  createdAt: string;
  updatedAt: string;
}

export interface ServiceApp {
  /** e.g. supabase, neondb, etc */
  app: string;
  /** base version */
  version: string;
  /** e.g. if neondb -> pageserver, safekeeper, etc. */
  service: string;
}

/** Base */
export interface CreateServiceRequest {
  name: string;
  type: ServiceType;
  app: ServiceApp | undefined;
  fields: ServiceNodeField[];
  serverId: string;
  parentId?: string | undefined;
}

/** always get latest the logs */
export interface LogsResponse {
  logs: string[];
  serviceId: string;
  status: ServiceStatus;
}

export interface ServiceNode {
  id: string;
  name: string;
  /** app of the service, like if supabase, app is supabase. or if neondb, app is neondb */
  app:
    | ServiceApp
    | undefined;
  /** type service, cluster or node */
  type: ServiceType;
  /** status of the service */
  status: ServiceStatus;
  /** fields of the service */
  fields: ServiceNodeField[];
  /** server id of the service */
  serverId: string;
  /** nodes. like if app = neondb, so the service children is safekeeper, pageserver, etc */
  nodes: ServiceNode[];
  /** ports of the service, like if app = neondb, ports is 5432, 5433, etc */
  ports: ServicePort[];
  /** image container of docker */
  container:
    | ServiceContainer
    | undefined;
  /** parent id of the service. default is null */
  parentId: string;
  /** timestamp at of the service */
  createdAt: string;
  updatedAt: string;
}

export interface ServiceNodesResponse {
  status: StatusCode;
  services: ServiceNode[];
  errors: ValidationError[];
  error?: string | undefined;
}

function createBaseQueryId(): QueryId {
  return { serviceId: "" };
}

export const QueryId: MessageFns<QueryId> = {
  encode(message: QueryId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceId !== "") {
      writer.uint32(10).string(message.serviceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryId {
    return { serviceId: isSet(object.serviceId) ? globalThis.String(object.serviceId) : "" };
  },

  toJSON(message: QueryId): unknown {
    const obj: any = {};
    if (message.serviceId !== "") {
      obj.serviceId = message.serviceId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryId>, I>>(base?: I): QueryId {
    return QueryId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryId>, I>>(object: I): QueryId {
    const message = createBaseQueryId();
    message.serviceId = object.serviceId ?? "";
    return message;
  },
};

function createBaseQueryServices(): QueryServices {
  return { page: 0, limit: 0, search: "", sort: "", order: "" };
}

export const QueryServices: MessageFns<QueryServices> = {
  encode(message: QueryServices, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.search !== "") {
      writer.uint32(26).string(message.search);
    }
    if (message.sort !== "") {
      writer.uint32(34).string(message.sort);
    }
    if (message.order !== "") {
      writer.uint32(42).string(message.order);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryServices {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryServices();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.search = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sort = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.order = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryServices {
    return {
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      search: isSet(object.search) ? globalThis.String(object.search) : "",
      sort: isSet(object.sort) ? globalThis.String(object.sort) : "",
      order: isSet(object.order) ? globalThis.String(object.order) : "",
    };
  },

  toJSON(message: QueryServices): unknown {
    const obj: any = {};
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.search !== "") {
      obj.search = message.search;
    }
    if (message.sort !== "") {
      obj.sort = message.sort;
    }
    if (message.order !== "") {
      obj.order = message.order;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryServices>, I>>(base?: I): QueryServices {
    return QueryServices.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryServices>, I>>(object: I): QueryServices {
    const message = createBaseQueryServices();
    message.page = object.page ?? 0;
    message.limit = object.limit ?? 0;
    message.search = object.search ?? "";
    message.sort = object.sort ?? "";
    message.order = object.order ?? "";
    return message;
  },
};

function createBaseQueryTakeActions(): QueryTakeActions {
  return { action: 0, serviceIds: [] };
}

export const QueryTakeActions: MessageFns<QueryTakeActions> = {
  encode(message: QueryTakeActions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.action !== 0) {
      writer.uint32(8).int32(message.action);
    }
    for (const v of message.serviceIds) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTakeActions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTakeActions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.serviceIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTakeActions {
    return {
      action: isSet(object.action) ? takeActionFromJSON(object.action) : 0,
      serviceIds: globalThis.Array.isArray(object?.serviceIds)
        ? object.serviceIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: QueryTakeActions): unknown {
    const obj: any = {};
    if (message.action !== 0) {
      obj.action = takeActionToJSON(message.action);
    }
    if (message.serviceIds?.length) {
      obj.serviceIds = message.serviceIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryTakeActions>, I>>(base?: I): QueryTakeActions {
    return QueryTakeActions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryTakeActions>, I>>(object: I): QueryTakeActions {
    const message = createBaseQueryTakeActions();
    message.action = object.action ?? 0;
    message.serviceIds = object.serviceIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseQueryLog(): QueryLog {
  return { serviceId: "", limit: 0, page: 0 };
}

export const QueryLog: MessageFns<QueryLog> = {
  encode(message: QueryLog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceId !== "") {
      writer.uint32(10).string(message.serviceId);
    }
    if (message.limit !== 0) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryLog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryLog {
    return {
      serviceId: isSet(object.serviceId) ? globalThis.String(object.serviceId) : "",
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
    };
  },

  toJSON(message: QueryLog): unknown {
    const obj: any = {};
    if (message.serviceId !== "") {
      obj.serviceId = message.serviceId;
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryLog>, I>>(base?: I): QueryLog {
    return QueryLog.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryLog>, I>>(object: I): QueryLog {
    const message = createBaseQueryLog();
    message.serviceId = object.serviceId ?? "";
    message.limit = object.limit ?? 0;
    message.page = object.page ?? 0;
    return message;
  },
};

function createBaseServiceNodeField(): ServiceNodeField {
  return { key: "", value: "", type: "" };
}

export const ServiceNodeField: MessageFns<ServiceNodeField> = {
  encode(message: ServiceNodeField, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceNodeField {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceNodeField();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceNodeField {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
    };
  },

  toJSON(message: ServiceNodeField): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceNodeField>, I>>(base?: I): ServiceNodeField {
    return ServiceNodeField.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceNodeField>, I>>(object: I): ServiceNodeField {
    const message = createBaseServiceNodeField();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    message.type = object.type ?? "";
    return message;
  },
};

function createBaseServicePort(): ServicePort {
  return { type: 0, port: 0, protocol: "", host: "", enabledExpose: false };
}

export const ServicePort: MessageFns<ServicePort> = {
  encode(message: ServicePort, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.port !== 0) {
      writer.uint32(16).int32(message.port);
    }
    if (message.protocol !== "") {
      writer.uint32(26).string(message.protocol);
    }
    if (message.host !== "") {
      writer.uint32(34).string(message.host);
    }
    if (message.enabledExpose !== false) {
      writer.uint32(40).bool(message.enabledExpose);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServicePort {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServicePort();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.port = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.protocol = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.enabledExpose = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServicePort {
    return {
      type: isSet(object.type) ? servicePortTypeFromJSON(object.type) : 0,
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      protocol: isSet(object.protocol) ? globalThis.String(object.protocol) : "",
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      enabledExpose: isSet(object.enabledExpose) ? globalThis.Boolean(object.enabledExpose) : false,
    };
  },

  toJSON(message: ServicePort): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = servicePortTypeToJSON(message.type);
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.protocol !== "") {
      obj.protocol = message.protocol;
    }
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.enabledExpose !== false) {
      obj.enabledExpose = message.enabledExpose;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServicePort>, I>>(base?: I): ServicePort {
    return ServicePort.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServicePort>, I>>(object: I): ServicePort {
    const message = createBaseServicePort();
    message.type = object.type ?? 0;
    message.port = object.port ?? 0;
    message.protocol = object.protocol ?? "";
    message.host = object.host ?? "";
    message.enabledExpose = object.enabledExpose ?? false;
    return message;
  },
};

function createBaseServiceContainer(): ServiceContainer {
  return { id: "", name: "", image: "", createdAt: "", updatedAt: "" };
}

export const ServiceContainer: MessageFns<ServiceContainer> = {
  encode(message: ServiceContainer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.image !== "") {
      writer.uint32(26).string(message.image);
    }
    if (message.createdAt !== "") {
      writer.uint32(34).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(42).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceContainer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceContainer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.image = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceContainer {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      image: isSet(object.image) ? globalThis.String(object.image) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: ServiceContainer): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.image !== "") {
      obj.image = message.image;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceContainer>, I>>(base?: I): ServiceContainer {
    return ServiceContainer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceContainer>, I>>(object: I): ServiceContainer {
    const message = createBaseServiceContainer();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.image = object.image ?? "";
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseServiceApp(): ServiceApp {
  return { app: "", version: "", service: "" };
}

export const ServiceApp: MessageFns<ServiceApp> = {
  encode(message: ServiceApp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.app !== "") {
      writer.uint32(10).string(message.app);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.service !== "") {
      writer.uint32(26).string(message.service);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceApp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceApp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.app = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.service = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceApp {
    return {
      app: isSet(object.app) ? globalThis.String(object.app) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      service: isSet(object.service) ? globalThis.String(object.service) : "",
    };
  },

  toJSON(message: ServiceApp): unknown {
    const obj: any = {};
    if (message.app !== "") {
      obj.app = message.app;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.service !== "") {
      obj.service = message.service;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceApp>, I>>(base?: I): ServiceApp {
    return ServiceApp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceApp>, I>>(object: I): ServiceApp {
    const message = createBaseServiceApp();
    message.app = object.app ?? "";
    message.version = object.version ?? "";
    message.service = object.service ?? "";
    return message;
  },
};

function createBaseCreateServiceRequest(): CreateServiceRequest {
  return { name: "", type: 0, app: undefined, fields: [], serverId: "", parentId: undefined };
}

export const CreateServiceRequest: MessageFns<CreateServiceRequest> = {
  encode(message: CreateServiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.app !== undefined) {
      ServiceApp.encode(message.app, writer.uint32(26).fork()).join();
    }
    for (const v of message.fields) {
      ServiceNodeField.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.serverId !== "") {
      writer.uint32(42).string(message.serverId);
    }
    if (message.parentId !== undefined) {
      writer.uint32(50).string(message.parentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateServiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateServiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.app = ServiceApp.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fields.push(ServiceNodeField.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.serverId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.parentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateServiceRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? serviceTypeFromJSON(object.type) : 0,
      app: isSet(object.app) ? ServiceApp.fromJSON(object.app) : undefined,
      fields: globalThis.Array.isArray(object?.fields)
        ? object.fields.map((e: any) => ServiceNodeField.fromJSON(e))
        : [],
      serverId: isSet(object.serverId) ? globalThis.String(object.serverId) : "",
      parentId: isSet(object.parentId) ? globalThis.String(object.parentId) : undefined,
    };
  },

  toJSON(message: CreateServiceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== 0) {
      obj.type = serviceTypeToJSON(message.type);
    }
    if (message.app !== undefined) {
      obj.app = ServiceApp.toJSON(message.app);
    }
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => ServiceNodeField.toJSON(e));
    }
    if (message.serverId !== "") {
      obj.serverId = message.serverId;
    }
    if (message.parentId !== undefined) {
      obj.parentId = message.parentId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateServiceRequest>, I>>(base?: I): CreateServiceRequest {
    return CreateServiceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateServiceRequest>, I>>(object: I): CreateServiceRequest {
    const message = createBaseCreateServiceRequest();
    message.name = object.name ?? "";
    message.type = object.type ?? 0;
    message.app = (object.app !== undefined && object.app !== null) ? ServiceApp.fromPartial(object.app) : undefined;
    message.fields = object.fields?.map((e) => ServiceNodeField.fromPartial(e)) || [];
    message.serverId = object.serverId ?? "";
    message.parentId = object.parentId ?? undefined;
    return message;
  },
};

function createBaseLogsResponse(): LogsResponse {
  return { logs: [], serviceId: "", status: 0 };
}

export const LogsResponse: MessageFns<LogsResponse> = {
  encode(message: LogsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.logs) {
      writer.uint32(10).string(v!);
    }
    if (message.serviceId !== "") {
      writer.uint32(18).string(message.serviceId);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.logs.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.serviceId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogsResponse {
    return {
      logs: globalThis.Array.isArray(object?.logs) ? object.logs.map((e: any) => globalThis.String(e)) : [],
      serviceId: isSet(object.serviceId) ? globalThis.String(object.serviceId) : "",
      status: isSet(object.status) ? serviceStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: LogsResponse): unknown {
    const obj: any = {};
    if (message.logs?.length) {
      obj.logs = message.logs;
    }
    if (message.serviceId !== "") {
      obj.serviceId = message.serviceId;
    }
    if (message.status !== 0) {
      obj.status = serviceStatusToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogsResponse>, I>>(base?: I): LogsResponse {
    return LogsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogsResponse>, I>>(object: I): LogsResponse {
    const message = createBaseLogsResponse();
    message.logs = object.logs?.map((e) => e) || [];
    message.serviceId = object.serviceId ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseServiceNode(): ServiceNode {
  return {
    id: "",
    name: "",
    app: undefined,
    type: 0,
    status: 0,
    fields: [],
    serverId: "",
    nodes: [],
    ports: [],
    container: undefined,
    parentId: "",
    createdAt: "",
    updatedAt: "",
  };
}

export const ServiceNode: MessageFns<ServiceNode> = {
  encode(message: ServiceNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.app !== undefined) {
      ServiceApp.encode(message.app, writer.uint32(26).fork()).join();
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    for (const v of message.fields) {
      ServiceNodeField.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.serverId !== "") {
      writer.uint32(58).string(message.serverId);
    }
    for (const v of message.nodes) {
      ServiceNode.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.ports) {
      ServicePort.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.container !== undefined) {
      ServiceContainer.encode(message.container, writer.uint32(82).fork()).join();
    }
    if (message.parentId !== "") {
      writer.uint32(90).string(message.parentId);
    }
    if (message.createdAt !== "") {
      writer.uint32(98).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(106).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.app = ServiceApp.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.fields.push(ServiceNodeField.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.serverId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.nodes.push(ServiceNode.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.ports.push(ServicePort.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.container = ServiceContainer.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.parentId = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceNode {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      app: isSet(object.app) ? ServiceApp.fromJSON(object.app) : undefined,
      type: isSet(object.type) ? serviceTypeFromJSON(object.type) : 0,
      status: isSet(object.status) ? serviceStatusFromJSON(object.status) : 0,
      fields: globalThis.Array.isArray(object?.fields)
        ? object.fields.map((e: any) => ServiceNodeField.fromJSON(e))
        : [],
      serverId: isSet(object.serverId) ? globalThis.String(object.serverId) : "",
      nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => ServiceNode.fromJSON(e)) : [],
      ports: globalThis.Array.isArray(object?.ports) ? object.ports.map((e: any) => ServicePort.fromJSON(e)) : [],
      container: isSet(object.container) ? ServiceContainer.fromJSON(object.container) : undefined,
      parentId: isSet(object.parentId) ? globalThis.String(object.parentId) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: ServiceNode): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.app !== undefined) {
      obj.app = ServiceApp.toJSON(message.app);
    }
    if (message.type !== 0) {
      obj.type = serviceTypeToJSON(message.type);
    }
    if (message.status !== 0) {
      obj.status = serviceStatusToJSON(message.status);
    }
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => ServiceNodeField.toJSON(e));
    }
    if (message.serverId !== "") {
      obj.serverId = message.serverId;
    }
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => ServiceNode.toJSON(e));
    }
    if (message.ports?.length) {
      obj.ports = message.ports.map((e) => ServicePort.toJSON(e));
    }
    if (message.container !== undefined) {
      obj.container = ServiceContainer.toJSON(message.container);
    }
    if (message.parentId !== "") {
      obj.parentId = message.parentId;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceNode>, I>>(base?: I): ServiceNode {
    return ServiceNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceNode>, I>>(object: I): ServiceNode {
    const message = createBaseServiceNode();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.app = (object.app !== undefined && object.app !== null) ? ServiceApp.fromPartial(object.app) : undefined;
    message.type = object.type ?? 0;
    message.status = object.status ?? 0;
    message.fields = object.fields?.map((e) => ServiceNodeField.fromPartial(e)) || [];
    message.serverId = object.serverId ?? "";
    message.nodes = object.nodes?.map((e) => ServiceNode.fromPartial(e)) || [];
    message.ports = object.ports?.map((e) => ServicePort.fromPartial(e)) || [];
    message.container = (object.container !== undefined && object.container !== null)
      ? ServiceContainer.fromPartial(object.container)
      : undefined;
    message.parentId = object.parentId ?? "";
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseServiceNodesResponse(): ServiceNodesResponse {
  return { status: 0, services: [], errors: [], error: undefined };
}

export const ServiceNodesResponse: MessageFns<ServiceNodesResponse> = {
  encode(message: ServiceNodesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    for (const v of message.services) {
      ServiceNode.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.errors) {
      ValidationError.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.error !== undefined) {
      writer.uint32(34).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceNodesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceNodesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.services.push(ServiceNode.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.errors.push(ValidationError.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceNodesResponse {
    return {
      status: isSet(object.status) ? statusCodeFromJSON(object.status) : 0,
      services: globalThis.Array.isArray(object?.services)
        ? object.services.map((e: any) => ServiceNode.fromJSON(e))
        : [],
      errors: globalThis.Array.isArray(object?.errors)
        ? object.errors.map((e: any) => ValidationError.fromJSON(e))
        : [],
      error: isSet(object.error) ? globalThis.String(object.error) : undefined,
    };
  },

  toJSON(message: ServiceNodesResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = statusCodeToJSON(message.status);
    }
    if (message.services?.length) {
      obj.services = message.services.map((e) => ServiceNode.toJSON(e));
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => ValidationError.toJSON(e));
    }
    if (message.error !== undefined) {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceNodesResponse>, I>>(base?: I): ServiceNodesResponse {
    return ServiceNodesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServiceNodesResponse>, I>>(object: I): ServiceNodesResponse {
    const message = createBaseServiceNodesResponse();
    message.status = object.status ?? 0;
    message.services = object.services?.map((e) => ServiceNode.fromPartial(e)) || [];
    message.errors = object.errors?.map((e) => ValidationError.fromPartial(e)) || [];
    message.error = object.error ?? undefined;
    return message;
  },
};

export interface ServicesService {
  All(request: QueryServices): Promise<ServiceNodesResponse>;
  One(request: QueryId): Promise<ServiceNode>;
  Create(request: CreateServiceRequest): Promise<ServiceNode>;
  Update(request: CreateServiceRequest): Promise<ServiceNode>;
  Delete(request: QueryId): Promise<MessageResponse>;
  TakeActions(request: QueryTakeActions): Promise<ServiceNodesResponse>;
  GetLogs(request: QueryLog): Promise<LogsResponse>;
}

export const ServicesServiceServiceName = "controlplane.ServicesService";
export class ServicesServiceClientImpl implements ServicesService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || ServicesServiceServiceName;
    this.rpc = rpc;
    this.All = this.All.bind(this);
    this.One = this.One.bind(this);
    this.Create = this.Create.bind(this);
    this.Update = this.Update.bind(this);
    this.Delete = this.Delete.bind(this);
    this.TakeActions = this.TakeActions.bind(this);
    this.GetLogs = this.GetLogs.bind(this);
  }
  All(request: QueryServices): Promise<ServiceNodesResponse> {
    const data = QueryServices.encode(request).finish();
    const promise = this.rpc.request(this.service, "All", data);
    return promise.then((data) => ServiceNodesResponse.decode(new BinaryReader(data)));
  }

  One(request: QueryId): Promise<ServiceNode> {
    const data = QueryId.encode(request).finish();
    const promise = this.rpc.request(this.service, "One", data);
    return promise.then((data) => ServiceNode.decode(new BinaryReader(data)));
  }

  Create(request: CreateServiceRequest): Promise<ServiceNode> {
    const data = CreateServiceRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Create", data);
    return promise.then((data) => ServiceNode.decode(new BinaryReader(data)));
  }

  Update(request: CreateServiceRequest): Promise<ServiceNode> {
    const data = CreateServiceRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Update", data);
    return promise.then((data) => ServiceNode.decode(new BinaryReader(data)));
  }

  Delete(request: QueryId): Promise<MessageResponse> {
    const data = QueryId.encode(request).finish();
    const promise = this.rpc.request(this.service, "Delete", data);
    return promise.then((data) => MessageResponse.decode(new BinaryReader(data)));
  }

  TakeActions(request: QueryTakeActions): Promise<ServiceNodesResponse> {
    const data = QueryTakeActions.encode(request).finish();
    const promise = this.rpc.request(this.service, "TakeActions", data);
    return promise.then((data) => ServiceNodesResponse.decode(new BinaryReader(data)));
  }

  GetLogs(request: QueryLog): Promise<LogsResponse> {
    const data = QueryLog.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetLogs", data);
    return promise.then((data) => LogsResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
