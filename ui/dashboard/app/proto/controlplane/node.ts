// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v3.12.4
// source: controlplane/node.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { MessageResponse, StatusCode, statusCodeFromJSON, statusCodeToJSON } from "../common/common";
import { ValidationError } from "../common/validation";

export const protobufPackage = "controlplane";

export interface NodeGraph {
  id: string;
  name: string;
  nodes: Node[];
  edges: Edge[];
  createdAt: string;
  updatedAt: string;
}

export interface Node {
  id: string;
  /** compute, pageserver, safekeeper, storage_broker */
  type: string;
  label: string;
  position: NodePosition | undefined;
  data: NodeData | undefined;
}

export interface NodePosition {
  x: number;
  y: number;
}

export interface NodeData {
  serverId: string;
  /** Specific fields for different node types */
  pgVersion: string;
  /** compute */
  pgPort: number;
  /** compute */
  exposeInternet: boolean;
  /** pageserver, safekeeper */
  backupStorageId: string;
}

export interface Edge {
  id: string;
  source: string;
  target: string;
  sourceHandle: string;
  targetHandle: string;
}

export interface CreateNodeGraphRequest {
  name: string;
  nodes: Node[];
  edges: Edge[];
}

export interface GetNodeGraphRequest {
  id: string;
}

export interface UpdateNodeGraphRequest {
  id: string;
  name: string;
  nodes: Node[];
  edges: Edge[];
}

export interface DeleteNodeGraphRequest {
  id: string;
}

export interface DeployNodeGraphRequest {
  id: string;
}

export interface GetNodeGraphStatusRequest {
  id: string;
}

export interface GetNodeGraphStatusResponse {
  /** DEPLOYING, RUNNING, STOPPED, ERROR */
  status: string;
  /** key: node_id, value: status */
  nodeStatuses: { [key: string]: string };
}

export interface GetNodeGraphStatusResponse_NodeStatusesEntry {
  key: string;
  value: string;
}

export interface GetDeploymentLogsRequest {
  id: string;
  /** Optional: filter by specific node in the graph */
  nodeId: string;
}

export interface GetDeploymentLogsResponse {
  logs: string[];
}

export interface NodeGraphResponse {
  status: StatusCode;
  graph: NodeGraph | undefined;
  errors: ValidationError[];
  error: string;
}

function createBaseNodeGraph(): NodeGraph {
  return { id: "", name: "", nodes: [], edges: [], createdAt: "", updatedAt: "" };
}

export const NodeGraph: MessageFns<NodeGraph> = {
  encode(message: NodeGraph, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    for (const v of message.nodes) {
      Node.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.edges) {
      Edge.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.createdAt !== "") {
      writer.uint32(42).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(50).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeGraph {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeGraph();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nodes.push(Node.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.edges.push(Edge.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeGraph {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => Node.fromJSON(e)) : [],
      edges: globalThis.Array.isArray(object?.edges) ? object.edges.map((e: any) => Edge.fromJSON(e)) : [],
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: NodeGraph): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => Node.toJSON(e));
    }
    if (message.edges?.length) {
      obj.edges = message.edges.map((e) => Edge.toJSON(e));
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeGraph>, I>>(base?: I): NodeGraph {
    return NodeGraph.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeGraph>, I>>(object: I): NodeGraph {
    const message = createBaseNodeGraph();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.nodes = object.nodes?.map((e) => Node.fromPartial(e)) || [];
    message.edges = object.edges?.map((e) => Edge.fromPartial(e)) || [];
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseNode(): Node {
  return { id: "", type: "", label: "", position: undefined, data: undefined };
}

export const Node: MessageFns<Node> = {
  encode(message: Node, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.label !== "") {
      writer.uint32(26).string(message.label);
    }
    if (message.position !== undefined) {
      NodePosition.encode(message.position, writer.uint32(34).fork()).join();
    }
    if (message.data !== undefined) {
      NodeData.encode(message.data, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Node {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.position = NodePosition.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.data = NodeData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Node {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      position: isSet(object.position) ? NodePosition.fromJSON(object.position) : undefined,
      data: isSet(object.data) ? NodeData.fromJSON(object.data) : undefined,
    };
  },

  toJSON(message: Node): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.position !== undefined) {
      obj.position = NodePosition.toJSON(message.position);
    }
    if (message.data !== undefined) {
      obj.data = NodeData.toJSON(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Node>, I>>(base?: I): Node {
    return Node.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Node>, I>>(object: I): Node {
    const message = createBaseNode();
    message.id = object.id ?? "";
    message.type = object.type ?? "";
    message.label = object.label ?? "";
    message.position = (object.position !== undefined && object.position !== null)
      ? NodePosition.fromPartial(object.position)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null) ? NodeData.fromPartial(object.data) : undefined;
    return message;
  },
};

function createBaseNodePosition(): NodePosition {
  return { x: 0, y: 0 };
}

export const NodePosition: MessageFns<NodePosition> = {
  encode(message: NodePosition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(9).double(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(17).double(message.y);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodePosition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodePosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.x = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.y = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodePosition {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
    };
  },

  toJSON(message: NodePosition): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodePosition>, I>>(base?: I): NodePosition {
    return NodePosition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodePosition>, I>>(object: I): NodePosition {
    const message = createBaseNodePosition();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    return message;
  },
};

function createBaseNodeData(): NodeData {
  return { serverId: "", pgVersion: "", pgPort: 0, exposeInternet: false, backupStorageId: "" };
}

export const NodeData: MessageFns<NodeData> = {
  encode(message: NodeData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serverId !== "") {
      writer.uint32(10).string(message.serverId);
    }
    if (message.pgVersion !== "") {
      writer.uint32(18).string(message.pgVersion);
    }
    if (message.pgPort !== 0) {
      writer.uint32(24).int32(message.pgPort);
    }
    if (message.exposeInternet !== false) {
      writer.uint32(32).bool(message.exposeInternet);
    }
    if (message.backupStorageId !== "") {
      writer.uint32(42).string(message.backupStorageId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serverId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pgVersion = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pgPort = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.exposeInternet = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.backupStorageId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeData {
    return {
      serverId: isSet(object.serverId) ? globalThis.String(object.serverId) : "",
      pgVersion: isSet(object.pgVersion) ? globalThis.String(object.pgVersion) : "",
      pgPort: isSet(object.pgPort) ? globalThis.Number(object.pgPort) : 0,
      exposeInternet: isSet(object.exposeInternet) ? globalThis.Boolean(object.exposeInternet) : false,
      backupStorageId: isSet(object.backupStorageId) ? globalThis.String(object.backupStorageId) : "",
    };
  },

  toJSON(message: NodeData): unknown {
    const obj: any = {};
    if (message.serverId !== "") {
      obj.serverId = message.serverId;
    }
    if (message.pgVersion !== "") {
      obj.pgVersion = message.pgVersion;
    }
    if (message.pgPort !== 0) {
      obj.pgPort = Math.round(message.pgPort);
    }
    if (message.exposeInternet !== false) {
      obj.exposeInternet = message.exposeInternet;
    }
    if (message.backupStorageId !== "") {
      obj.backupStorageId = message.backupStorageId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeData>, I>>(base?: I): NodeData {
    return NodeData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeData>, I>>(object: I): NodeData {
    const message = createBaseNodeData();
    message.serverId = object.serverId ?? "";
    message.pgVersion = object.pgVersion ?? "";
    message.pgPort = object.pgPort ?? 0;
    message.exposeInternet = object.exposeInternet ?? false;
    message.backupStorageId = object.backupStorageId ?? "";
    return message;
  },
};

function createBaseEdge(): Edge {
  return { id: "", source: "", target: "", sourceHandle: "", targetHandle: "" };
}

export const Edge: MessageFns<Edge> = {
  encode(message: Edge, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.source !== "") {
      writer.uint32(18).string(message.source);
    }
    if (message.target !== "") {
      writer.uint32(26).string(message.target);
    }
    if (message.sourceHandle !== "") {
      writer.uint32(34).string(message.sourceHandle);
    }
    if (message.targetHandle !== "") {
      writer.uint32(42).string(message.targetHandle);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Edge {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEdge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.target = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sourceHandle = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.targetHandle = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Edge {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      sourceHandle: isSet(object.sourceHandle) ? globalThis.String(object.sourceHandle) : "",
      targetHandle: isSet(object.targetHandle) ? globalThis.String(object.targetHandle) : "",
    };
  },

  toJSON(message: Edge): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.sourceHandle !== "") {
      obj.sourceHandle = message.sourceHandle;
    }
    if (message.targetHandle !== "") {
      obj.targetHandle = message.targetHandle;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Edge>, I>>(base?: I): Edge {
    return Edge.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Edge>, I>>(object: I): Edge {
    const message = createBaseEdge();
    message.id = object.id ?? "";
    message.source = object.source ?? "";
    message.target = object.target ?? "";
    message.sourceHandle = object.sourceHandle ?? "";
    message.targetHandle = object.targetHandle ?? "";
    return message;
  },
};

function createBaseCreateNodeGraphRequest(): CreateNodeGraphRequest {
  return { name: "", nodes: [], edges: [] };
}

export const CreateNodeGraphRequest: MessageFns<CreateNodeGraphRequest> = {
  encode(message: CreateNodeGraphRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.nodes) {
      Node.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.edges) {
      Edge.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateNodeGraphRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateNodeGraphRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodes.push(Node.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.edges.push(Edge.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateNodeGraphRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => Node.fromJSON(e)) : [],
      edges: globalThis.Array.isArray(object?.edges) ? object.edges.map((e: any) => Edge.fromJSON(e)) : [],
    };
  },

  toJSON(message: CreateNodeGraphRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => Node.toJSON(e));
    }
    if (message.edges?.length) {
      obj.edges = message.edges.map((e) => Edge.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateNodeGraphRequest>, I>>(base?: I): CreateNodeGraphRequest {
    return CreateNodeGraphRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateNodeGraphRequest>, I>>(object: I): CreateNodeGraphRequest {
    const message = createBaseCreateNodeGraphRequest();
    message.name = object.name ?? "";
    message.nodes = object.nodes?.map((e) => Node.fromPartial(e)) || [];
    message.edges = object.edges?.map((e) => Edge.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetNodeGraphRequest(): GetNodeGraphRequest {
  return { id: "" };
}

export const GetNodeGraphRequest: MessageFns<GetNodeGraphRequest> = {
  encode(message: GetNodeGraphRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNodeGraphRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNodeGraphRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNodeGraphRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetNodeGraphRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNodeGraphRequest>, I>>(base?: I): GetNodeGraphRequest {
    return GetNodeGraphRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNodeGraphRequest>, I>>(object: I): GetNodeGraphRequest {
    const message = createBaseGetNodeGraphRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseUpdateNodeGraphRequest(): UpdateNodeGraphRequest {
  return { id: "", name: "", nodes: [], edges: [] };
}

export const UpdateNodeGraphRequest: MessageFns<UpdateNodeGraphRequest> = {
  encode(message: UpdateNodeGraphRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    for (const v of message.nodes) {
      Node.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.edges) {
      Edge.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateNodeGraphRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateNodeGraphRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nodes.push(Node.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.edges.push(Edge.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateNodeGraphRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => Node.fromJSON(e)) : [],
      edges: globalThis.Array.isArray(object?.edges) ? object.edges.map((e: any) => Edge.fromJSON(e)) : [],
    };
  },

  toJSON(message: UpdateNodeGraphRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => Node.toJSON(e));
    }
    if (message.edges?.length) {
      obj.edges = message.edges.map((e) => Edge.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateNodeGraphRequest>, I>>(base?: I): UpdateNodeGraphRequest {
    return UpdateNodeGraphRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateNodeGraphRequest>, I>>(object: I): UpdateNodeGraphRequest {
    const message = createBaseUpdateNodeGraphRequest();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.nodes = object.nodes?.map((e) => Node.fromPartial(e)) || [];
    message.edges = object.edges?.map((e) => Edge.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeleteNodeGraphRequest(): DeleteNodeGraphRequest {
  return { id: "" };
}

export const DeleteNodeGraphRequest: MessageFns<DeleteNodeGraphRequest> = {
  encode(message: DeleteNodeGraphRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteNodeGraphRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteNodeGraphRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteNodeGraphRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeleteNodeGraphRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteNodeGraphRequest>, I>>(base?: I): DeleteNodeGraphRequest {
    return DeleteNodeGraphRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteNodeGraphRequest>, I>>(object: I): DeleteNodeGraphRequest {
    const message = createBaseDeleteNodeGraphRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseDeployNodeGraphRequest(): DeployNodeGraphRequest {
  return { id: "" };
}

export const DeployNodeGraphRequest: MessageFns<DeployNodeGraphRequest> = {
  encode(message: DeployNodeGraphRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeployNodeGraphRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployNodeGraphRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployNodeGraphRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeployNodeGraphRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeployNodeGraphRequest>, I>>(base?: I): DeployNodeGraphRequest {
    return DeployNodeGraphRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeployNodeGraphRequest>, I>>(object: I): DeployNodeGraphRequest {
    const message = createBaseDeployNodeGraphRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseGetNodeGraphStatusRequest(): GetNodeGraphStatusRequest {
  return { id: "" };
}

export const GetNodeGraphStatusRequest: MessageFns<GetNodeGraphStatusRequest> = {
  encode(message: GetNodeGraphStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNodeGraphStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNodeGraphStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNodeGraphStatusRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetNodeGraphStatusRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNodeGraphStatusRequest>, I>>(base?: I): GetNodeGraphStatusRequest {
    return GetNodeGraphStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNodeGraphStatusRequest>, I>>(object: I): GetNodeGraphStatusRequest {
    const message = createBaseGetNodeGraphStatusRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseGetNodeGraphStatusResponse(): GetNodeGraphStatusResponse {
  return { status: "", nodeStatuses: {} };
}

export const GetNodeGraphStatusResponse: MessageFns<GetNodeGraphStatusResponse> = {
  encode(message: GetNodeGraphStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    Object.entries(message.nodeStatuses).forEach(([key, value]) => {
      GetNodeGraphStatusResponse_NodeStatusesEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNodeGraphStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNodeGraphStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = GetNodeGraphStatusResponse_NodeStatusesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.nodeStatuses[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNodeGraphStatusResponse {
    return {
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      nodeStatuses: isObject(object.nodeStatuses)
        ? Object.entries(object.nodeStatuses).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: GetNodeGraphStatusResponse): unknown {
    const obj: any = {};
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.nodeStatuses) {
      const entries = Object.entries(message.nodeStatuses);
      if (entries.length > 0) {
        obj.nodeStatuses = {};
        entries.forEach(([k, v]) => {
          obj.nodeStatuses[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNodeGraphStatusResponse>, I>>(base?: I): GetNodeGraphStatusResponse {
    return GetNodeGraphStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNodeGraphStatusResponse>, I>>(object: I): GetNodeGraphStatusResponse {
    const message = createBaseGetNodeGraphStatusResponse();
    message.status = object.status ?? "";
    message.nodeStatuses = Object.entries(object.nodeStatuses ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseGetNodeGraphStatusResponse_NodeStatusesEntry(): GetNodeGraphStatusResponse_NodeStatusesEntry {
  return { key: "", value: "" };
}

export const GetNodeGraphStatusResponse_NodeStatusesEntry: MessageFns<GetNodeGraphStatusResponse_NodeStatusesEntry> = {
  encode(
    message: GetNodeGraphStatusResponse_NodeStatusesEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNodeGraphStatusResponse_NodeStatusesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNodeGraphStatusResponse_NodeStatusesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNodeGraphStatusResponse_NodeStatusesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: GetNodeGraphStatusResponse_NodeStatusesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNodeGraphStatusResponse_NodeStatusesEntry>, I>>(
    base?: I,
  ): GetNodeGraphStatusResponse_NodeStatusesEntry {
    return GetNodeGraphStatusResponse_NodeStatusesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNodeGraphStatusResponse_NodeStatusesEntry>, I>>(
    object: I,
  ): GetNodeGraphStatusResponse_NodeStatusesEntry {
    const message = createBaseGetNodeGraphStatusResponse_NodeStatusesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetDeploymentLogsRequest(): GetDeploymentLogsRequest {
  return { id: "", nodeId: "" };
}

export const GetDeploymentLogsRequest: MessageFns<GetDeploymentLogsRequest> = {
  encode(message: GetDeploymentLogsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.nodeId !== "") {
      writer.uint32(18).string(message.nodeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDeploymentLogsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDeploymentLogsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDeploymentLogsRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
    };
  },

  toJSON(message: GetDeploymentLogsRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDeploymentLogsRequest>, I>>(base?: I): GetDeploymentLogsRequest {
    return GetDeploymentLogsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDeploymentLogsRequest>, I>>(object: I): GetDeploymentLogsRequest {
    const message = createBaseGetDeploymentLogsRequest();
    message.id = object.id ?? "";
    message.nodeId = object.nodeId ?? "";
    return message;
  },
};

function createBaseGetDeploymentLogsResponse(): GetDeploymentLogsResponse {
  return { logs: [] };
}

export const GetDeploymentLogsResponse: MessageFns<GetDeploymentLogsResponse> = {
  encode(message: GetDeploymentLogsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.logs) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDeploymentLogsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDeploymentLogsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.logs.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDeploymentLogsResponse {
    return { logs: globalThis.Array.isArray(object?.logs) ? object.logs.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: GetDeploymentLogsResponse): unknown {
    const obj: any = {};
    if (message.logs?.length) {
      obj.logs = message.logs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDeploymentLogsResponse>, I>>(base?: I): GetDeploymentLogsResponse {
    return GetDeploymentLogsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDeploymentLogsResponse>, I>>(object: I): GetDeploymentLogsResponse {
    const message = createBaseGetDeploymentLogsResponse();
    message.logs = object.logs?.map((e) => e) || [];
    return message;
  },
};

function createBaseNodeGraphResponse(): NodeGraphResponse {
  return { status: 0, graph: undefined, errors: [], error: "" };
}

export const NodeGraphResponse: MessageFns<NodeGraphResponse> = {
  encode(message: NodeGraphResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.graph !== undefined) {
      NodeGraph.encode(message.graph, writer.uint32(18).fork()).join();
    }
    for (const v of message.errors) {
      ValidationError.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.error !== "") {
      writer.uint32(34).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeGraphResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeGraphResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.graph = NodeGraph.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.errors.push(ValidationError.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeGraphResponse {
    return {
      status: isSet(object.status) ? statusCodeFromJSON(object.status) : 0,
      graph: isSet(object.graph) ? NodeGraph.fromJSON(object.graph) : undefined,
      errors: globalThis.Array.isArray(object?.errors)
        ? object.errors.map((e: any) => ValidationError.fromJSON(e))
        : [],
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: NodeGraphResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = statusCodeToJSON(message.status);
    }
    if (message.graph !== undefined) {
      obj.graph = NodeGraph.toJSON(message.graph);
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => ValidationError.toJSON(e));
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeGraphResponse>, I>>(base?: I): NodeGraphResponse {
    return NodeGraphResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeGraphResponse>, I>>(object: I): NodeGraphResponse {
    const message = createBaseNodeGraphResponse();
    message.status = object.status ?? 0;
    message.graph = (object.graph !== undefined && object.graph !== null)
      ? NodeGraph.fromPartial(object.graph)
      : undefined;
    message.errors = object.errors?.map((e) => ValidationError.fromPartial(e)) || [];
    message.error = object.error ?? "";
    return message;
  },
};

export interface NodeService {
  CreateNodeGraph(request: CreateNodeGraphRequest): Promise<NodeGraphResponse>;
  GetNodeGraph(request: GetNodeGraphRequest): Promise<NodeGraphResponse>;
  UpdateNodeGraph(request: UpdateNodeGraphRequest): Promise<NodeGraphResponse>;
  DeleteNodeGraph(request: DeleteNodeGraphRequest): Promise<MessageResponse>;
  DeployNodeGraph(request: DeployNodeGraphRequest): Promise<MessageResponse>;
  GetNodeGraphStatus(request: GetNodeGraphStatusRequest): Promise<GetNodeGraphStatusResponse>;
  GetDeploymentLogs(request: GetDeploymentLogsRequest): Promise<GetDeploymentLogsResponse>;
}

export const NodeServiceServiceName = "controlplane.NodeService";
export class NodeServiceClientImpl implements NodeService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || NodeServiceServiceName;
    this.rpc = rpc;
    this.CreateNodeGraph = this.CreateNodeGraph.bind(this);
    this.GetNodeGraph = this.GetNodeGraph.bind(this);
    this.UpdateNodeGraph = this.UpdateNodeGraph.bind(this);
    this.DeleteNodeGraph = this.DeleteNodeGraph.bind(this);
    this.DeployNodeGraph = this.DeployNodeGraph.bind(this);
    this.GetNodeGraphStatus = this.GetNodeGraphStatus.bind(this);
    this.GetDeploymentLogs = this.GetDeploymentLogs.bind(this);
  }
  CreateNodeGraph(request: CreateNodeGraphRequest): Promise<NodeGraphResponse> {
    const data = CreateNodeGraphRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateNodeGraph", data);
    return promise.then((data) => NodeGraphResponse.decode(new BinaryReader(data)));
  }

  GetNodeGraph(request: GetNodeGraphRequest): Promise<NodeGraphResponse> {
    const data = GetNodeGraphRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetNodeGraph", data);
    return promise.then((data) => NodeGraphResponse.decode(new BinaryReader(data)));
  }

  UpdateNodeGraph(request: UpdateNodeGraphRequest): Promise<NodeGraphResponse> {
    const data = UpdateNodeGraphRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateNodeGraph", data);
    return promise.then((data) => NodeGraphResponse.decode(new BinaryReader(data)));
  }

  DeleteNodeGraph(request: DeleteNodeGraphRequest): Promise<MessageResponse> {
    const data = DeleteNodeGraphRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteNodeGraph", data);
    return promise.then((data) => MessageResponse.decode(new BinaryReader(data)));
  }

  DeployNodeGraph(request: DeployNodeGraphRequest): Promise<MessageResponse> {
    const data = DeployNodeGraphRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeployNodeGraph", data);
    return promise.then((data) => MessageResponse.decode(new BinaryReader(data)));
  }

  GetNodeGraphStatus(request: GetNodeGraphStatusRequest): Promise<GetNodeGraphStatusResponse> {
    const data = GetNodeGraphStatusRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetNodeGraphStatus", data);
    return promise.then((data) => GetNodeGraphStatusResponse.decode(new BinaryReader(data)));
  }

  GetDeploymentLogs(request: GetDeploymentLogsRequest): Promise<GetDeploymentLogsResponse> {
    const data = GetDeploymentLogsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetDeploymentLogs", data);
    return promise.then((data) => GetDeploymentLogsResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
