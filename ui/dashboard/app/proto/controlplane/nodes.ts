// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v3.12.4
// source: controlplane/nodes.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Empty } from "../common/common";
import { ValidationError } from "../common/validation";

export const protobufPackage = "controlplane";

export interface Node {
  id: string;
  name: string;
  /** compute, pageserver, safekeeper, storage_broker */
  type: string;
  serverId: string;
  /** JSON string for specific fields */
  configJson: string;
  positionX: number;
  positionY: number;
  /** created, deploying, running, error, stopped */
  status: string;
}

export interface NodeConnection {
  id: string;
  sourceNodeId: string;
  targetNodeId: string;
}

export interface CreateNodeRequest {
  name: string;
  type: string;
  serverId: string;
  configJson: string;
  positionX: number;
  positionY: number;
}

export interface UpdateNodeRequest {
  id: string;
  name: string;
  serverId: string;
  configJson: string;
  positionX: number;
  positionY: number;
}

export interface DeleteNodeRequest {
  id: string;
}

export interface GetNodeRequest {
  id: string;
}

export interface NodeResponse {
  status: number;
  node: Node | undefined;
  errors: ValidationError[];
  error: string;
}

export interface ListNodesResponse {
  status: number;
  nodes: Node[];
  error: string;
}

export interface CreateConnectionRequest {
  sourceNodeId: string;
  targetNodeId: string;
}

export interface DeleteConnectionRequest {
  id: string;
}

export interface ConnectionResponse {
  status: number;
  connection: NodeConnection | undefined;
  error: string;
}

export interface ListConnectionsResponse {
  status: number;
  connections: NodeConnection[];
  error: string;
}

export interface NodeGraphStatusResponse {
  status: number;
  nodeStatuses: NodeStatus[];
}

export interface NodeStatus {
  nodeId: string;
  status: string;
  message: string;
}

export interface GetDeploymentLogsRequest {
  nodeId: string;
}

export interface GetDeploymentLogsResponse {
  status: number;
  logs: string[];
}

function createBaseNode(): Node {
  return { id: "", name: "", type: "", serverId: "", configJson: "", positionX: 0, positionY: 0, status: "" };
}

export const Node: MessageFns<Node> = {
  encode(message: Node, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    if (message.serverId !== "") {
      writer.uint32(34).string(message.serverId);
    }
    if (message.configJson !== "") {
      writer.uint32(42).string(message.configJson);
    }
    if (message.positionX !== 0) {
      writer.uint32(49).double(message.positionX);
    }
    if (message.positionY !== 0) {
      writer.uint32(57).double(message.positionY);
    }
    if (message.status !== "") {
      writer.uint32(66).string(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Node {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.serverId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.configJson = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.positionX = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 57) {
            break;
          }

          message.positionY = reader.double();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.status = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Node {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      serverId: isSet(object.serverId) ? globalThis.String(object.serverId) : "",
      configJson: isSet(object.configJson) ? globalThis.String(object.configJson) : "",
      positionX: isSet(object.positionX) ? globalThis.Number(object.positionX) : 0,
      positionY: isSet(object.positionY) ? globalThis.Number(object.positionY) : 0,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
    };
  },

  toJSON(message: Node): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.serverId !== "") {
      obj.serverId = message.serverId;
    }
    if (message.configJson !== "") {
      obj.configJson = message.configJson;
    }
    if (message.positionX !== 0) {
      obj.positionX = message.positionX;
    }
    if (message.positionY !== 0) {
      obj.positionY = message.positionY;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Node>, I>>(base?: I): Node {
    return Node.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Node>, I>>(object: I): Node {
    const message = createBaseNode();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.type = object.type ?? "";
    message.serverId = object.serverId ?? "";
    message.configJson = object.configJson ?? "";
    message.positionX = object.positionX ?? 0;
    message.positionY = object.positionY ?? 0;
    message.status = object.status ?? "";
    return message;
  },
};

function createBaseNodeConnection(): NodeConnection {
  return { id: "", sourceNodeId: "", targetNodeId: "" };
}

export const NodeConnection: MessageFns<NodeConnection> = {
  encode(message: NodeConnection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.sourceNodeId !== "") {
      writer.uint32(18).string(message.sourceNodeId);
    }
    if (message.targetNodeId !== "") {
      writer.uint32(26).string(message.targetNodeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeConnection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeConnection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sourceNodeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.targetNodeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeConnection {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      sourceNodeId: isSet(object.sourceNodeId) ? globalThis.String(object.sourceNodeId) : "",
      targetNodeId: isSet(object.targetNodeId) ? globalThis.String(object.targetNodeId) : "",
    };
  },

  toJSON(message: NodeConnection): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.sourceNodeId !== "") {
      obj.sourceNodeId = message.sourceNodeId;
    }
    if (message.targetNodeId !== "") {
      obj.targetNodeId = message.targetNodeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeConnection>, I>>(base?: I): NodeConnection {
    return NodeConnection.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeConnection>, I>>(object: I): NodeConnection {
    const message = createBaseNodeConnection();
    message.id = object.id ?? "";
    message.sourceNodeId = object.sourceNodeId ?? "";
    message.targetNodeId = object.targetNodeId ?? "";
    return message;
  },
};

function createBaseCreateNodeRequest(): CreateNodeRequest {
  return { name: "", type: "", serverId: "", configJson: "", positionX: 0, positionY: 0 };
}

export const CreateNodeRequest: MessageFns<CreateNodeRequest> = {
  encode(message: CreateNodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.serverId !== "") {
      writer.uint32(26).string(message.serverId);
    }
    if (message.configJson !== "") {
      writer.uint32(34).string(message.configJson);
    }
    if (message.positionX !== 0) {
      writer.uint32(41).double(message.positionX);
    }
    if (message.positionY !== 0) {
      writer.uint32(49).double(message.positionY);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateNodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateNodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.serverId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.configJson = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.positionX = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.positionY = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateNodeRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      serverId: isSet(object.serverId) ? globalThis.String(object.serverId) : "",
      configJson: isSet(object.configJson) ? globalThis.String(object.configJson) : "",
      positionX: isSet(object.positionX) ? globalThis.Number(object.positionX) : 0,
      positionY: isSet(object.positionY) ? globalThis.Number(object.positionY) : 0,
    };
  },

  toJSON(message: CreateNodeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.serverId !== "") {
      obj.serverId = message.serverId;
    }
    if (message.configJson !== "") {
      obj.configJson = message.configJson;
    }
    if (message.positionX !== 0) {
      obj.positionX = message.positionX;
    }
    if (message.positionY !== 0) {
      obj.positionY = message.positionY;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateNodeRequest>, I>>(base?: I): CreateNodeRequest {
    return CreateNodeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateNodeRequest>, I>>(object: I): CreateNodeRequest {
    const message = createBaseCreateNodeRequest();
    message.name = object.name ?? "";
    message.type = object.type ?? "";
    message.serverId = object.serverId ?? "";
    message.configJson = object.configJson ?? "";
    message.positionX = object.positionX ?? 0;
    message.positionY = object.positionY ?? 0;
    return message;
  },
};

function createBaseUpdateNodeRequest(): UpdateNodeRequest {
  return { id: "", name: "", serverId: "", configJson: "", positionX: 0, positionY: 0 };
}

export const UpdateNodeRequest: MessageFns<UpdateNodeRequest> = {
  encode(message: UpdateNodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.serverId !== "") {
      writer.uint32(26).string(message.serverId);
    }
    if (message.configJson !== "") {
      writer.uint32(34).string(message.configJson);
    }
    if (message.positionX !== 0) {
      writer.uint32(41).double(message.positionX);
    }
    if (message.positionY !== 0) {
      writer.uint32(49).double(message.positionY);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateNodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateNodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.serverId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.configJson = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.positionX = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.positionY = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateNodeRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      serverId: isSet(object.serverId) ? globalThis.String(object.serverId) : "",
      configJson: isSet(object.configJson) ? globalThis.String(object.configJson) : "",
      positionX: isSet(object.positionX) ? globalThis.Number(object.positionX) : 0,
      positionY: isSet(object.positionY) ? globalThis.Number(object.positionY) : 0,
    };
  },

  toJSON(message: UpdateNodeRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.serverId !== "") {
      obj.serverId = message.serverId;
    }
    if (message.configJson !== "") {
      obj.configJson = message.configJson;
    }
    if (message.positionX !== 0) {
      obj.positionX = message.positionX;
    }
    if (message.positionY !== 0) {
      obj.positionY = message.positionY;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateNodeRequest>, I>>(base?: I): UpdateNodeRequest {
    return UpdateNodeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateNodeRequest>, I>>(object: I): UpdateNodeRequest {
    const message = createBaseUpdateNodeRequest();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.serverId = object.serverId ?? "";
    message.configJson = object.configJson ?? "";
    message.positionX = object.positionX ?? 0;
    message.positionY = object.positionY ?? 0;
    return message;
  },
};

function createBaseDeleteNodeRequest(): DeleteNodeRequest {
  return { id: "" };
}

export const DeleteNodeRequest: MessageFns<DeleteNodeRequest> = {
  encode(message: DeleteNodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteNodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteNodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteNodeRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeleteNodeRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteNodeRequest>, I>>(base?: I): DeleteNodeRequest {
    return DeleteNodeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteNodeRequest>, I>>(object: I): DeleteNodeRequest {
    const message = createBaseDeleteNodeRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseGetNodeRequest(): GetNodeRequest {
  return { id: "" };
}

export const GetNodeRequest: MessageFns<GetNodeRequest> = {
  encode(message: GetNodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNodeRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetNodeRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNodeRequest>, I>>(base?: I): GetNodeRequest {
    return GetNodeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNodeRequest>, I>>(object: I): GetNodeRequest {
    const message = createBaseGetNodeRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseNodeResponse(): NodeResponse {
  return { status: 0, node: undefined, errors: [], error: "" };
}

export const NodeResponse: MessageFns<NodeResponse> = {
  encode(message: NodeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.node !== undefined) {
      Node.encode(message.node, writer.uint32(18).fork()).join();
    }
    for (const v of message.errors) {
      ValidationError.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.error !== "") {
      writer.uint32(34).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.node = Node.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.errors.push(ValidationError.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeResponse {
    return {
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
      node: isSet(object.node) ? Node.fromJSON(object.node) : undefined,
      errors: globalThis.Array.isArray(object?.errors)
        ? object.errors.map((e: any) => ValidationError.fromJSON(e))
        : [],
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: NodeResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    if (message.node !== undefined) {
      obj.node = Node.toJSON(message.node);
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => ValidationError.toJSON(e));
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeResponse>, I>>(base?: I): NodeResponse {
    return NodeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeResponse>, I>>(object: I): NodeResponse {
    const message = createBaseNodeResponse();
    message.status = object.status ?? 0;
    message.node = (object.node !== undefined && object.node !== null) ? Node.fromPartial(object.node) : undefined;
    message.errors = object.errors?.map((e) => ValidationError.fromPartial(e)) || [];
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseListNodesResponse(): ListNodesResponse {
  return { status: 0, nodes: [], error: "" };
}

export const ListNodesResponse: MessageFns<ListNodesResponse> = {
  encode(message: ListNodesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    for (const v of message.nodes) {
      Node.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNodesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNodesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodes.push(Node.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNodesResponse {
    return {
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
      nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => Node.fromJSON(e)) : [],
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: ListNodesResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => Node.toJSON(e));
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListNodesResponse>, I>>(base?: I): ListNodesResponse {
    return ListNodesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListNodesResponse>, I>>(object: I): ListNodesResponse {
    const message = createBaseListNodesResponse();
    message.status = object.status ?? 0;
    message.nodes = object.nodes?.map((e) => Node.fromPartial(e)) || [];
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseCreateConnectionRequest(): CreateConnectionRequest {
  return { sourceNodeId: "", targetNodeId: "" };
}

export const CreateConnectionRequest: MessageFns<CreateConnectionRequest> = {
  encode(message: CreateConnectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceNodeId !== "") {
      writer.uint32(10).string(message.sourceNodeId);
    }
    if (message.targetNodeId !== "") {
      writer.uint32(18).string(message.targetNodeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateConnectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateConnectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sourceNodeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.targetNodeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateConnectionRequest {
    return {
      sourceNodeId: isSet(object.sourceNodeId) ? globalThis.String(object.sourceNodeId) : "",
      targetNodeId: isSet(object.targetNodeId) ? globalThis.String(object.targetNodeId) : "",
    };
  },

  toJSON(message: CreateConnectionRequest): unknown {
    const obj: any = {};
    if (message.sourceNodeId !== "") {
      obj.sourceNodeId = message.sourceNodeId;
    }
    if (message.targetNodeId !== "") {
      obj.targetNodeId = message.targetNodeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateConnectionRequest>, I>>(base?: I): CreateConnectionRequest {
    return CreateConnectionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateConnectionRequest>, I>>(object: I): CreateConnectionRequest {
    const message = createBaseCreateConnectionRequest();
    message.sourceNodeId = object.sourceNodeId ?? "";
    message.targetNodeId = object.targetNodeId ?? "";
    return message;
  },
};

function createBaseDeleteConnectionRequest(): DeleteConnectionRequest {
  return { id: "" };
}

export const DeleteConnectionRequest: MessageFns<DeleteConnectionRequest> = {
  encode(message: DeleteConnectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteConnectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteConnectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteConnectionRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeleteConnectionRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteConnectionRequest>, I>>(base?: I): DeleteConnectionRequest {
    return DeleteConnectionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteConnectionRequest>, I>>(object: I): DeleteConnectionRequest {
    const message = createBaseDeleteConnectionRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseConnectionResponse(): ConnectionResponse {
  return { status: 0, connection: undefined, error: "" };
}

export const ConnectionResponse: MessageFns<ConnectionResponse> = {
  encode(message: ConnectionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.connection !== undefined) {
      NodeConnection.encode(message.connection, writer.uint32(18).fork()).join();
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.connection = NodeConnection.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectionResponse {
    return {
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
      connection: isSet(object.connection) ? NodeConnection.fromJSON(object.connection) : undefined,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: ConnectionResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    if (message.connection !== undefined) {
      obj.connection = NodeConnection.toJSON(message.connection);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConnectionResponse>, I>>(base?: I): ConnectionResponse {
    return ConnectionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConnectionResponse>, I>>(object: I): ConnectionResponse {
    const message = createBaseConnectionResponse();
    message.status = object.status ?? 0;
    message.connection = (object.connection !== undefined && object.connection !== null)
      ? NodeConnection.fromPartial(object.connection)
      : undefined;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseListConnectionsResponse(): ListConnectionsResponse {
  return { status: 0, connections: [], error: "" };
}

export const ListConnectionsResponse: MessageFns<ListConnectionsResponse> = {
  encode(message: ListConnectionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    for (const v of message.connections) {
      NodeConnection.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListConnectionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListConnectionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.connections.push(NodeConnection.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListConnectionsResponse {
    return {
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
      connections: globalThis.Array.isArray(object?.connections)
        ? object.connections.map((e: any) => NodeConnection.fromJSON(e))
        : [],
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: ListConnectionsResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    if (message.connections?.length) {
      obj.connections = message.connections.map((e) => NodeConnection.toJSON(e));
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListConnectionsResponse>, I>>(base?: I): ListConnectionsResponse {
    return ListConnectionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListConnectionsResponse>, I>>(object: I): ListConnectionsResponse {
    const message = createBaseListConnectionsResponse();
    message.status = object.status ?? 0;
    message.connections = object.connections?.map((e) => NodeConnection.fromPartial(e)) || [];
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseNodeGraphStatusResponse(): NodeGraphStatusResponse {
  return { status: 0, nodeStatuses: [] };
}

export const NodeGraphStatusResponse: MessageFns<NodeGraphStatusResponse> = {
  encode(message: NodeGraphStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    for (const v of message.nodeStatuses) {
      NodeStatus.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeGraphStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeGraphStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodeStatuses.push(NodeStatus.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeGraphStatusResponse {
    return {
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
      nodeStatuses: globalThis.Array.isArray(object?.nodeStatuses)
        ? object.nodeStatuses.map((e: any) => NodeStatus.fromJSON(e))
        : [],
    };
  },

  toJSON(message: NodeGraphStatusResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    if (message.nodeStatuses?.length) {
      obj.nodeStatuses = message.nodeStatuses.map((e) => NodeStatus.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeGraphStatusResponse>, I>>(base?: I): NodeGraphStatusResponse {
    return NodeGraphStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeGraphStatusResponse>, I>>(object: I): NodeGraphStatusResponse {
    const message = createBaseNodeGraphStatusResponse();
    message.status = object.status ?? 0;
    message.nodeStatuses = object.nodeStatuses?.map((e) => NodeStatus.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNodeStatus(): NodeStatus {
  return { nodeId: "", status: "", message: "" };
}

export const NodeStatus: MessageFns<NodeStatus> = {
  encode(message: NodeStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeStatus {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: NodeStatus): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeStatus>, I>>(base?: I): NodeStatus {
    return NodeStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeStatus>, I>>(object: I): NodeStatus {
    const message = createBaseNodeStatus();
    message.nodeId = object.nodeId ?? "";
    message.status = object.status ?? "";
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseGetDeploymentLogsRequest(): GetDeploymentLogsRequest {
  return { nodeId: "" };
}

export const GetDeploymentLogsRequest: MessageFns<GetDeploymentLogsRequest> = {
  encode(message: GetDeploymentLogsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDeploymentLogsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDeploymentLogsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDeploymentLogsRequest {
    return { nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "" };
  },

  toJSON(message: GetDeploymentLogsRequest): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDeploymentLogsRequest>, I>>(base?: I): GetDeploymentLogsRequest {
    return GetDeploymentLogsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDeploymentLogsRequest>, I>>(object: I): GetDeploymentLogsRequest {
    const message = createBaseGetDeploymentLogsRequest();
    message.nodeId = object.nodeId ?? "";
    return message;
  },
};

function createBaseGetDeploymentLogsResponse(): GetDeploymentLogsResponse {
  return { status: 0, logs: [] };
}

export const GetDeploymentLogsResponse: MessageFns<GetDeploymentLogsResponse> = {
  encode(message: GetDeploymentLogsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    for (const v of message.logs) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDeploymentLogsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDeploymentLogsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.logs.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDeploymentLogsResponse {
    return {
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
      logs: globalThis.Array.isArray(object?.logs) ? object.logs.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: GetDeploymentLogsResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    if (message.logs?.length) {
      obj.logs = message.logs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDeploymentLogsResponse>, I>>(base?: I): GetDeploymentLogsResponse {
    return GetDeploymentLogsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDeploymentLogsResponse>, I>>(object: I): GetDeploymentLogsResponse {
    const message = createBaseGetDeploymentLogsResponse();
    message.status = object.status ?? 0;
    message.logs = object.logs?.map((e) => e) || [];
    return message;
  },
};

export interface NodeService {
  CreateNode(request: CreateNodeRequest): Promise<NodeResponse>;
  UpdateNode(request: UpdateNodeRequest): Promise<NodeResponse>;
  DeleteNode(request: DeleteNodeRequest): Promise<NodeResponse>;
  GetNode(request: GetNodeRequest): Promise<NodeResponse>;
  ListNodes(request: Empty): Promise<ListNodesResponse>;
  CreateConnection(request: CreateConnectionRequest): Promise<ConnectionResponse>;
  DeleteConnection(request: DeleteConnectionRequest): Promise<ConnectionResponse>;
  ListConnections(request: Empty): Promise<ListConnectionsResponse>;
  /** Phase 2 RPCs */
  GetNodeGraphStatus(request: Empty): Promise<NodeGraphStatusResponse>;
  GetDeploymentLogs(request: GetDeploymentLogsRequest): Promise<GetDeploymentLogsResponse>;
}

export const NodeServiceServiceName = "controlplane.NodeService";
export class NodeServiceClientImpl implements NodeService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || NodeServiceServiceName;
    this.rpc = rpc;
    this.CreateNode = this.CreateNode.bind(this);
    this.UpdateNode = this.UpdateNode.bind(this);
    this.DeleteNode = this.DeleteNode.bind(this);
    this.GetNode = this.GetNode.bind(this);
    this.ListNodes = this.ListNodes.bind(this);
    this.CreateConnection = this.CreateConnection.bind(this);
    this.DeleteConnection = this.DeleteConnection.bind(this);
    this.ListConnections = this.ListConnections.bind(this);
    this.GetNodeGraphStatus = this.GetNodeGraphStatus.bind(this);
    this.GetDeploymentLogs = this.GetDeploymentLogs.bind(this);
  }
  CreateNode(request: CreateNodeRequest): Promise<NodeResponse> {
    const data = CreateNodeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateNode", data);
    return promise.then((data) => NodeResponse.decode(new BinaryReader(data)));
  }

  UpdateNode(request: UpdateNodeRequest): Promise<NodeResponse> {
    const data = UpdateNodeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateNode", data);
    return promise.then((data) => NodeResponse.decode(new BinaryReader(data)));
  }

  DeleteNode(request: DeleteNodeRequest): Promise<NodeResponse> {
    const data = DeleteNodeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteNode", data);
    return promise.then((data) => NodeResponse.decode(new BinaryReader(data)));
  }

  GetNode(request: GetNodeRequest): Promise<NodeResponse> {
    const data = GetNodeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetNode", data);
    return promise.then((data) => NodeResponse.decode(new BinaryReader(data)));
  }

  ListNodes(request: Empty): Promise<ListNodesResponse> {
    const data = Empty.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListNodes", data);
    return promise.then((data) => ListNodesResponse.decode(new BinaryReader(data)));
  }

  CreateConnection(request: CreateConnectionRequest): Promise<ConnectionResponse> {
    const data = CreateConnectionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateConnection", data);
    return promise.then((data) => ConnectionResponse.decode(new BinaryReader(data)));
  }

  DeleteConnection(request: DeleteConnectionRequest): Promise<ConnectionResponse> {
    const data = DeleteConnectionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteConnection", data);
    return promise.then((data) => ConnectionResponse.decode(new BinaryReader(data)));
  }

  ListConnections(request: Empty): Promise<ListConnectionsResponse> {
    const data = Empty.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListConnections", data);
    return promise.then((data) => ListConnectionsResponse.decode(new BinaryReader(data)));
  }

  GetNodeGraphStatus(request: Empty): Promise<NodeGraphStatusResponse> {
    const data = Empty.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetNodeGraphStatus", data);
    return promise.then((data) => NodeGraphStatusResponse.decode(new BinaryReader(data)));
  }

  GetDeploymentLogs(request: GetDeploymentLogsRequest): Promise<GetDeploymentLogsResponse> {
    const data = GetDeploymentLogsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetDeploymentLogs", data);
    return promise.then((data) => GetDeploymentLogsResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
